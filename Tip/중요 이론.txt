객체지향언어란? [특징, 장점, 단점, 종류]
https://radait.tistory.com/4

오버라이딩 -> 동적바인딩 == 다형성을 실현했다!

-질문-

1.자바기본
2.mvc
3.ioc와 aop
4.오버로딩, 오버라이딩

이 코드가 해결하고싶었던 문제는 뭘까?

class <<< 설명
 dao vo view controller

하나의 클래스에서 하나의 관련작업을 처리하고있습니다.
private 외부에서 클래스의 변수에 직접접근할수없도록 은닉했다.
메서드명이 기능을 짐작할수있게 지어져있었다.

- 팀원을 배려xxx
- 주석을 달았어야했다.

------------------------------------------
설계순서
1. 요구조건분석
2. 개념설계  ERD==데이터 조직도
3. 논리설계  테이블
4. 물리설계 
5. 구현 및 확인
	SQL : CRUD
	인터프리터 언어
	컴파일XXX 번역과 동시에 실행

--------------------------------------------

DBMS 데이터 관리가 용이
 1. 데이터 중복 최소화
 2. 정보 표준화
 3. 협업 용이 == 공유 용이

--------------------------------------------

[내장 객체]
 JSP ---> Servlet파일로 변환
	application, session, out, request, .....
 내장객체들은 주로 데이터를 주고 받을때 사용됨

--------------------------------------------
=프로젝트 문서화=
제목
환경설정
코드분석
☆오류해결과정
  원인과 해결방법을 설명
데이터 가공
---------------------------------------------

[MVC]
M :  DB연동 JDBC관련코드
	DAO  CRUD 비즈니스메서드(보통 5개)  DB연동
	VO    데이터를 담기위한 객체
V  :  사용자에게 인터페이스를 제공(.jsp)
C  :  M-V 연결다리 
	V 사용자가 요청한 명령이 무엇인지
	M에게 알려주는 연결다리 역할

요구조건분석
 대략적인 메서드 개수
 대략적인 페이지 개수
 대략적인 사용데이터 개수
----------------------------------------------

Spring [.xml]
 "IoC와 AOP를 지원하는 경량의 컨테이너 프레임워크"
IoC -> 객체생성을 내가안함    제어의 역행 == [낮은 결합도]
  컨테이너가 new를 함
  JAVA코드에서 new가 사라짐
  결합도가 낮아짐!★
   ex) IPhone+AppleWatch
AOP -> 응집도가 높아짐!★    관점지향 프로그래밍 == [높은 응집도]

코드의 제 1가치
 == 유지보수
 -> 낮은결합도+높은응집도
----------------------------------------------

1. *.do 요청
2. web.xml에 의해 servlet-mapping
3. 서블릿컨테이너--객체생성-->DS
4. 요청분석 => JSP 팀 프로젝트(if(action.equals("/login.do")))
5. 요청에 맞는 컨트롤러 객체를 반환 => new LoginController();
6. 5의 역할을 담당하는 HM
7. 컨트롤러 객체가 요청을 처리, 결과로 MAV객체를 반환 => ActionForward
 - VR의 등장으로 String을 반환함(경로)
 - 스프링 컨테이너의 개입으로 MAV.addObjet()처리 가능해짐 -> MAV를 반환함
8. VR가 MAV에서 V(경로)정보를 추출
	=> 정보를 출력하는 페이지들을 더 안정적으로 서비스 가능해짐

-------------------------------------------------
AOP

 Aspect Oriented Programming
 관점 지향 프로그래밍
↓ 핵심관심 core concern 비즈니스 메서드 CRUD
→ (트랜잭션,로그,예외처리) 횡단관심 crosscutting concern

☆유지보수
핵심관심 전후에 수행되는 횡단관심들의 유지보수 향상을 위해 AOP사용!

"관심분리 Separation of Concern"
AOP 사용을 위한 준비
 1) pom.xml에서 AOP관련 라이브러리 설치
 2) 네임스페이스를 추가
 3) .xml에 결합관련 설정을 작성
	a) la=new LogAdvice();을 위한 <bean>설정
	b) 비즈니스메서드 호출시, la.printLog()호출될수있도록 설정

1. 조인포인트
	포인트컷 후보
	모든 비즈니스 메서드
	 -> 횡단관심에게 선택된 메서드를 포인트컷이라 함
2. 포인트컷 == 핵심관심(비즈니스 메서드,CRUD)
	-> CUD : 트랜잭션,보안
	-> R : 권한확인,로깅
3. 어드바이스 == 횡단관심
	AOP를 지원하는 컨테이너에 의해 결합될수있기때문에,
	별도의 클래스로 저장됨!
4. 애스팩트
	포인트컷+횡단관심의 결합
5. 위빙(Weaving)
	실제로 애스팩트를 참고해서 결합을 완성해주는 행위
	스프링 컨테이너는 런타임시에 처리함

"어드바이스가 동작하는 시점"
 before
	비즈니스 메서드가 실행되기 전에 수행됨
 after-returning
	비즈니스 메서드 결과데이터를 반환시 수행됨
 after-throwing
	비즈니스 메서드 수행중에 예외발생시 수행됨
 after
	비즈니스 메서드가 실행된 후에 finally처럼 수행됨
 around☆
	비즈니스 메서드를 탈취,(=>ProceedingJoinPoint pjp 인자 필수!)
	전후로 공통로직을 수행할 수 있음


----------------------------------------------------
☆Command 객체
 -> VO객체를 new,setter
   단, 파라미터와 멤버변수(속성,프로퍼티)의 이름을 "정확하게" 맞춰주셔야합니다!
1. 사용자의 입력값을 추출
2. 객체생성하여,
3. setter사용

---------------------------------------------------
[다국어처리]
[다국어 처리] : 국제화

언어별 페이지를 각각 만듦
  -> 유지보수 불리 
  => 언어정보가 저장된 파일 == 메세지 파일
			       .properties
메세지 파일
  -> 파일을 읽는 객체
  -> 현재 지역정보 전달
	브라우저에서 서버로 요청을 전송하면,
	해당 지역정보가 HTTP헤더에 자동으로 전송됨
	SessionLocalResolver를 널리 사용함
		=> 다른 지역정보로 변경해서 전송하기위해서는 Interceptor가 필요함!
		: 파라미터의 이름이 lang인 정보로 다른 지역정보로의 변경이 가능하다!!!
  -> View 제공
     1) taglib 지시어
     2) <spring:message>
 

-파일명 규칙-
messageSource_en.properties
messageSource_ko.properties

-----------------------------------------------
[Mybatis 프레임워크]

장점) 코드가 간결해짐
       SQL 쿼리문을 자바코드로부터 분리
	-> 응집도 높임
	-> 결합도 낮춤
	=> .xml파일에서 분리한 쿼리문을 관리함!

// sql문을 자바코드에서 완전히 분리한것을 확인!
// 정보 -> .xml에 설정하고 저장!!

------------------------------------------------
[JPA]
JDBCUtil -> JDBCTemplate -> Mybatis -> JPA

ORM(object relation mapping)
 자바 객체 - 테이블 매핑
 자바 객체에 저장된 데이터 <->테이블의 Row정보

 이러한 과정에서 SQL구문과 자바코드들이 많이 사용됨
 지금까지는 자바클래스 or 외부XML파일로 관리
 이것들을 ORM프레임워크로 자동생성해보자!
 ->  "Hibernate"를 사용할 예정
 => 다양한 프레임워크들이 등장했고, 
     그런 이들의 표준화 작업이 필요하게됨 == JPA
					(Java Persistence API)
				ORM프레임워크들의 공통 인터페이스를 제공함
					JDBC API와 유사

엔티티 클래스(영속 클래스)
 : DB의 테이블과 매핑될 클래스, 그에 관련된 설정을 작성한 공간
  VO클래스 만들때와 유사하게 진행됨

----------------------------------------------------

1. 성능테스트
   - [입사후포부]
   - B단계는 향후 개발과제로 남겨놓았습니다.
    -> B를 완성하기위해 c,d,e등의 기능|기술을 공부할 예정입니다.
   - 오류경험
    -> 에러원인 + 해결방안
 서버 성능테스트를 왜 할까요?
   - 부하 발생xxx
   - 병목의 발생을 막아야한다!
   - 트래픽 발생량이 많을것으로 예상되는 새로운 서비스를 오픈할때 수행하는 테스트
   - 클라이언트의 요청처리를 잘 수행하는지 사전에 미리 체크하는 용도로 활용

2. 반응형 프로그래밍(1)
   반응형 웹 어플리케이션 템플릿 
   -> 사용자의 접속기기가 다양화됨
   -> 미디어쿼리
 반응형 프로그래밍
   "상태관리" == 변화하는 데이터를 관리
   ex) 네이버 지도,좋아요,팔로우,...
   SPA: JS -> React,Vue,... => 변화된 데이터에 반응하는 프로그래밍
※ 컴포넌트: 반복하여 재사용하기위해 로직을 작은 부분들로 분리하여 설계 및 작업
      낮은 의존도를 실현
   -> 페이지는 여러개의 컴포넌트로 구성되어있고,
      컴포넌트는 데이터를 화면에 출력
      인터렉티브한 페이지를 구현할때에 용이
※ 데이터를 하나의 스트림으로 관리
   스트림 == 이벤트들의 최종 output,
    ex) 키보드 입력, 마우스 클릭, ... , 값,에러,수행시간 등을 가질수있음
   '선언형 프로그래밍' Event Listener ----> Event
            <--이벤트 발생 알림--

3. 클래스 다이어그램
   : 핵심만 표현!
   : 상속   vs   interface(실체화)
   : 연관관계   vs   의존관계
     생명주기가 서로 관련된 관계     매개변수,파라미터,반환값으로 사용됨

4. SW 개발 방법론 "애자일"
   보드--->킥보드--->스쿠터--->오토바이--->자동차
   '소비자 중심' 요구사항(기능)
   : 빠르고 변화에 유연하며 적응(Adaptation)적인 개발

5. 반응형 프로그래밍(2)
   SPA -> React,Vue,Angular,...
   SPA          <-> MPA
   서버 재방문x         JSP
   유저와 상호작용이 많을때 사용됨   URI로 사용자의 요청을 파악하여 해당 리소스를 응답하는 처리방식
   첫 페이지 로딩 느림         화면의 깜빡임이 존재
               UX(사용자 경험)에 불리

6. DOM vs BOM
   BOM이 보다 상위개념
   DOM: 브라우저가 이해할수있는 문서. 페이지를 사용자에게 화면에서 출력.
      이해한 내용을 페이지로 구현할때에 트리구조로 구성함
   BOM: 웹 브라우저,페이지 제어에 관련된 객체

7. RESTful
   API 설계문서 : 가이드북 -> 외부 API
   URI와 HttpMethod(CRUD)를 사용하여 자원에 대한 행위를 표현

8. 쿠키
   http: 비연결성(Client가 요청,Server가 응답.응답을 완료하면 연결 끊음)
      -> 무상태성(서버가 클라이언트를 식별할수없음)을 보완하기위해 사용하는 "쿠키"

   요청시 정보들이 요청Header에 실림.같은 도메인에서 사용

   쿠키: 장바구니,로그인상태,~~일동안 보지않기,... -> 중요,용량이 큰 정보는 저장xxx

+) cache : CPU 처리속도 | 메모리 저장용량
   -> CPU의 처리속도를 못따라가는 병목현상이 발생 => 보완하기위해 cache

9. CORS 이슈
 cross origin resource sharing
 교차 출처 리소스 공유
 - 외부로부터 데이터를 받아올수가없었음! -> CORS 구현 => 관련 이슈

----------------------------------------------------

1. Web Server VS WAS
 내 포트폴리오는 웹 서버가 존재한다고 생각했는데...
 면접관: 웹 서버는 어딨죠...??
   사용하신 웹 서버에 대한 설명이 없네요??
 +) Spring Boot은 웹서버 내장되어있음
 +) 웹 != 인터넷

2. Spring Boot
 Spring: 설정이 복잡함.XML파일-컨테이너가 무언가를 자동처리할수있게해줌
 Boot: 이러한 설정파일을 줄여나가자! @
   1) 의존성 관리중의 버전충돌위험이 매우 낮아짐
      pom.xml에 <dependency>추가하는 행동은 버전충돌의 위험이존재했었음
      spring-boot-starter 덕분에 버전충돌위험 감소
   2) 보다 다양하고 강력한 @
   3) WAS내장되어있음

3. 피드백 해설
설계서가 정교하여 짜임새가있었다. -> view component를 작성해보면 더 좋을듯하다.
ERD,UF+LP ---> 비즈니스메서드의 input,output를 페이지단위로 확인할수있는 표형태의 서식

UI|UX를 고려한 프로그램이다.(강점)
 -> 사용자를 배려한 화면구성이다.

기능 모듈화 잘 이루어져있다.(강점) : 낮은 의존도 / 높은 응집도 / 유지보수 용이
 -> 돌을 주워서 -> 돌을 네모모양으로 조각 -> 피라미드위치까지 이동시키기 -> 세모모양으로 쌓는다.

MVC가 분리되지않은 코드가 발견되어, 해당 부분 수정해야한다.
  로그와 사용자의 뷰는 다르다!
  .jsp에 java코드 존재xxx

에러솔루션 작업이 잘 되어있다.
  오류나 에러의 발생원인 + 그 문제에대한 해결방안
  +) 해결되지않은 과제,해결하지못한 오류 -> develop할 예정이다!

4. 웹표준
 웹 페이지를 구성할때에 지켜야하는 규칙
 한국형 웹 콘텐츠 접근성 지침
 인식,운용,이해의 용이성, 견고성
 -> 브라우저에 독립적인, 동일한 컨텐츠들을 제공할수있게됨!
 -> SEO(검색엔진최적화)에 유리
 -> 분석이 보다 용이해지므로, 개발자의 편의성 증가
 == 웹 접근성이 높아진다!

5. 프레임워크
 - 공통적인 개발환경이 제공됨
 - 개발자는 로직만 신경쓰면되니까, 편의성 증가
 - 설정사항들이 기본제공되는 부분들이 다수 존재
   -> IoC
      <->
   라이브러리
     재사용을 위한 코드덩어리(이미 구성된 로직)
     타인이 잘 만들어놓은것을 가져와서 이용
     흐름이 이미 구성되어있음.그대로 사용만하는것







